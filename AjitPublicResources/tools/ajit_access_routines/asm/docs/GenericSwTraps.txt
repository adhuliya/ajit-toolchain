
		A Generic Software Trap Handler
		    Madhav Desai


1.  Pre-condition
------------------

	The program is running in window W.  Window
	W has a stack pointer SP(W) and a frame pointer FP(W).

	At the point a software trap is triggered, the 
	arguments to be passed to the software trap handler
	are the tbr, and input registers i0,i1,i2 in 
	window W


2. There is an event
----------------------

	A software trap is triggered.  The window changes to 
		T = W-1

	----------------------------------------------------
        Note: window W registers i0,i1,i2 have to be passed
	to the generic software trap handler (see below)
	----------------------------------------------------


	The frame pointer of T is 
		FP(T) = SP(W)

	SP(T) may or may not be set.

	If it is not set, it will be 0x0 since
	we initialize all stack pointers to 0x0
	in the startup sequence.

	T may be valid or invalid.

3. The action
----------------

	If T is invalid, make T-1 invalid
		by saving its registers to stack

	Give T a new stack.. (***)
		Save SP(T) into X

		If SP(T) is not defined (ie, is 0x0)
			SP(T) = FP(T) - 320
		else
			SP(T) = SP(T) - 320

	Save T's psr, X (original SP(T)), globals, input-regs, %l1,%l2, 
	registers into this stack.

	Make the stack of T bigger to allow window overflow
	saves
		SP(T) = SP(T) - 96

	Enable traps (interrupt ilvl = 15).

	----------------------------------------------------------------
	Get the arguments for the software trap handler.
        These are assumed to be in the first 3 input registers in window
	W.
	----------------------------------------------------------------

	call the C interrupt handler
	
	On return:
	Recover T's psr, globals, input_regs, %l1, %l2, %sp
	registers from the stack (***) marked above.

	jmpl/rett and move on.. 
	--------------------------------------------------------------------
	Note that we do not reexecute the trap instruction which got us here.
	--------------------------------------------------------------------

4. Summary
-----------------

	Our generic ISR uses the same stack that the
	program is using.  This makes things less complicated
	than using a separate ISR stack!


