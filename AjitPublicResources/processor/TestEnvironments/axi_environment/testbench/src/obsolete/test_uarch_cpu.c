//cpu_only_testbench.c
//
// This is a testbench for the C model of the Sparc V8 cpu.
// The testbench contains:
// 	- the Sparc V8 cpu 
// 	- a byte-addressable array to model the main memory
// 	- a threads that models the instruction fetch interface between cpu and memory
// 	- a threads that models the data read/write interface between cpu and memory
// 	- display driver and keyboard driver threads for 
// 	  performing basic polled IO.
//
//
//Author : Sarath Mohan
//Modified by: Neha Karanjkar (4 April 2015)
//	Modification: Removed the resetSparc thread and 
//	registered all pipes before their use explicitly
//	using register_pipe() function. The unregistered 
//	pipes were possibly causing the executable to hang
//	occasionally.
//	
// Modified by Madhav Desai (August 1+, 2015).
//      to start testing the CPU uarch C and VHDL models.
//      
// Modified Nov. 18, 2016 to start testing Aa-v3 model (MPD,PS)
//
//
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>

#include <string.h>
#include "Ajit_Hardware_Configuration.h"
#include "Pipes.h"
#include "Ancillary.h"
#include "pipeHandler.h"
#include "memory.h"
#include "IO_drivers.h"
#include "sparc_stdio.h"
#include "cpu_env_model.h"
#include "uarch_debug_utils.h"
#include "uarch_bist.h"

#ifdef GENERATE_LOGS_IN_TWIN_CPU_TESTBENCH
#include "Logger.h"
#endif

#ifdef DOVAL
#include "do_val.h"
#endif

#ifdef GDB
#include "StartGPBThreads.h"
#endif

#ifdef CONNECTRIFFA
#include "cpu_env_to_riffa.h"
#endif

#ifdef USE_GNUPTH
#include <pth.h>
#include <GnuPthUtils.h>
#define __SLEEP__(x)  pth_usleep(x);
#else
#include <pthread.h>
#include "pthreadUtils.h"
#define __SLEEP__(x)  usleep(x);
#endif



#define PROCESSOR_UNDEFINED    0
#define PROCESSOR_IN_RESET     1
#define PROCESSOR_RUN_STATE    2
#define PROCESSOR_ERROR_STATE  3


MUTEX_DECL_NONSTATIC(__g_mutex__);
MUTEX_DECL_NONSTATIC(__pmode_mutex__);
uint8_t g_pmode = 0;


// drain the blocking pipe and keep updating
// g_pmode flag.
void listenToPmode()
{
	while(1)
	{
		//read the processor_mode pipe,
		//The last 2 bits encode the mode.
		uint8_t pmode = read_uint8("AJIT_to_ENV_processor_mode");
		//the model is encoded in to the last 2 bits
		pmode=pmode&0x3;

		MUTEX_LOCK(__pmode_mutex__);
		g_pmode = pmode;
		MUTEX_UNLOCK(__pmode_mutex__);	

		__SLEEP__(100);
	}
}
DEFINE_THREAD(listenToPmode);

void putTheProcessorInReset()
{
	/*TODO*/
	fprintf(stderr,"Entered putTheProcessorInReset().\n");
	write_uint8("ENV_to_AJIT_irl", 0);
	write_uint8("ENV_to_AJIT_reset", 1);
	fprintf(stderr,"asserted reset.\n");
	// ensure that it has gone to reset.
	while(1)
	{
		MUTEX_LOCK(__pmode_mutex__);
		uint8_t pmode = g_pmode;
		MUTEX_UNLOCK(__pmode_mutex__);
		if(pmode == PROCESSOR_IN_RESET)
			break;
		__SLEEP__(1000);
		fprintf(stderr,"processor-mode=%d\n", pmode);
	}
	fprintf(stderr,"processor put into reset-mode.\n");
	return;
}


void checkErrorStateAndExit(void)
{
	
	//pb_error is asserted by the cpu when 
	//a "ta 0" instruction is encountered,
	//indicating end of the program.
	while(1)
	{
		MUTEX_LOCK(__pmode_mutex__);
		uint8_t pmode = g_pmode;
		MUTEX_UNLOCK(__pmode_mutex__);

		// bottom two bits of the pmode indicate if the
		// processor is in error.
 		uint8_t rval = (0x3 & pmode);

		if(rval == PROCESSOR_ERROR_STATE)
			break;
		
		__SLEEP__(1000);
	}
	fprintf(stderr, "\nError state detected\n");
	#ifdef GENERATE_LOGS_IN_TWIN_CPU_TESTBENCH
	print_queue(); 
	#endif
	return;
}

// command-line parsing
int opt;
int interrupted_flag = 0;


void Handle_Segfault(int signal)
{
	fprintf(stderr, "Error:  segmentation fault! giving up!!\n");
	
	//print out the log of last 100
	//messages generated by the cpu
	//before exiting
	#ifdef GENERATE_LOGS_IN_TWIN_CPU_TESTBENCH
	print_queue(); 
	#endif
	exit(-1);
}



void Handle_Ctrl_C(int signal)
{
	static int count = 0;
	interrupted_flag = 1;

	if(count == 1)
	{
		fprintf(stderr, "second Ctrl-C, exit\n");

		//print out the log of last 100
		//messages generated by the cpu
		//before exiting
		#ifdef GENERATE_LOGS_IN_TWIN_CPU_TESTBENCH
		print_queue(); 
		#endif

		exit(-1);
	}

	fprintf(stderr, "Ctrl-C, continue.. type once more to kill process!!\n");
	count++;
}

void print_usage(char* app_name)
{
#ifndef DOVAL
#ifdef GDB
	fprintf(stderr, "USAGE:   %s -m <mmap-file> -p <port-number> [-t <trace-file>] [-w <write-trace-file>] [-S logger-server-ip] [-P logger-server-port] \n", app_name);
	fprintf(stderr, "   -m <mmap-file>     : required, specifies memory-map of processor for this test.\n");
	fprintf(stderr, "   -p <port-number>  : required,  specifies the port number to be used for connecting to GDB.\n");
	fprintf(stderr, "   -t <trace-file>   : optional. if specified, a trace file is generated, else redirected to stderr.\n");
	fprintf(stderr, "   -w <reg-writes-dump>: optional. if specified, a writes dump is generated.\n");
	fprintf(stderr, "   -S <log-server-ip-addr>  : optional, specifies a logging-server-ip-addr to compare traces.\n");
	fprintf(stderr, "   -P <log-server-ip-port>  : use with -S, specifies a logging-server-port to compare traces.\n");
	fprintf(stderr, "   -i, if specified, spins after processor goes into error mode until interrupted.\n");
	fprintf(stderr, "                                                                         \n");
	fprintf(stderr, "EXAMPLE:  \n");
	fprintf(stderr, "          %s -m add_test.mmap -p 8888 -t add_test.trace -w add_test.wtrace\n", app_name);

#else
	fprintf(stderr, "USAGE:   %s -m <mmap-file> [-t <trace-file>] [-b] [-d] [-s] [-S logger-server-ip] [-P logger-server-port] \n", app_name);
	fprintf(stderr, "   -m <mmap-file>      : required, specifies memory-map of processor for this test.\n");
	fprintf(stderr, "   -t <trace-file>     : optional. if specified, a trace file is generated, else redirected to stderr.\n");
	fprintf(stderr, "   -w <reg-writes-dump>: optional. if specified, a writes dump is generated.\n");
	fprintf(stderr, "   -S <log-server-ip-addr>  : optional, specifies a logging-server-ip-addr to compare traces.\n");
	fprintf(stderr, "   -P <log-server-ip-port>  : use with -S, specifies a logging-server-port to compare traces.\n");
	fprintf(stderr, "   -i, if specified, spins after processor goes into error mode until interrupted.\n");
	fprintf(stderr, "                                                                         \n");
	fprintf(stderr, "EXAMPLE:  \n");
	fprintf(stderr, "          %s -m add_test.mmap -t add_test.trace\n", app_name);
	fprintf(stderr, "                                                                         \n");
	fprintf(stderr, "                                                                         \n");
	fprintf(stderr, "Deprecated options (may not be supported forever):\n");
	fprintf(stderr, "   use -b to run bist test, -d to generate pipe-debug log\n");
	fprintf(stderr, "   use -s to run the CPU in single-step mode.\n");
#endif
#else
	fprintf(stderr, "USAGE:   %s -m <mmap-file> -r <results-file> -l <log-file>  [-t <trace-file>] [-s] [-S logger-server-ip] [-P logger-server-port] \n", 
					app_name);
	fprintf(stderr, "   -m <mmap-file>     : required, specifies memory-map of processor for this test.\n");
	fprintf(stderr, "   -r <results-file>  : required,  specifies expected register/memory values at end of run.\n");
	fprintf(stderr, "   -l <log-file>      : required, specifies a log-file of the validation checks.\n");
	fprintf(stderr, "   -t <trace-file>   : optional. if specified, a trace file is generated, else redirected to stderr.\n");
	fprintf(stderr, "   -w <reg-writes-dump>: optional. if specified, a writes dump is generated.\n");
	fprintf(stderr, "   -S <log-server-ip-addr>  : optional, specifies a logging-server-ip-addr to compare traces.\n");
	fprintf(stderr, "   -P <log-server-ip-port>  : use with -S, specifies a logging-server-port to compare traces.\n");
	fprintf(stderr, "   -i, if specified, spins after processor goes into error mode until interrupted.\n");
	fprintf(stderr, "   use -s to run the CPU in single-step mode.\n");
	fprintf(stderr, "                                                                         \n");
	fprintf(stderr, "EXAMPLE:  \n");
	fprintf(stderr, "          %s -m add_test.mmap -l add_test.log -r add_test.results -t add_test.trace -w add_test.wtrace \n", app_name);

#endif
}

int main(int argc, char **argv)
{
	int main_ret_val = 0;
	int verbose_flag = 0;

	time_t start_t, end_t, total_t;

	signal(SIGINT,  Handle_Ctrl_C);
        signal(SIGTERM, Handle_Segfault);

	// for generating trace
	FILE* trace_file;
	trace_file = NULL;
	
    	reg_write_file = NULL;	
	long_reg_write_file = NULL;

	logger_server_ip_address = NULL;
	logger_server_port_number = -1;

	int log_flag = 0;

	//check arguments
	char* mmap_file_name = NULL;
	char* trace_file_name  = NULL;
	char* log_file_name = NULL;
	char* results_file_name = NULL;
	char* reg_write_file_name = NULL;
	char* long_reg_write_file_name = NULL;

	char spin_flag = 0;
#ifdef GDB
	
	port_number[0] = '\0';
	if (argc < 3)
	{
		print_usage(argv[0]);
		return(1);
	}
#else
	if (argc < 2)
	{
		print_usage(argv[0]);
		return(1);
	}
#endif

#ifdef USE_GNUPTH
	pth_init();
#endif

	uint8_t run_bist = 0;
	uint8_t debug = 0;
	uint8_t single_step = 0;
	uint8_t do_val = 0;
	
#ifdef DOVAL
	while ((opt = getopt(argc, argv, "m:t:l:r:w:bdsviS:P:")) != -1) {
#else
#ifdef GDB
	while ((opt = getopt(argc, argv, "m:p:t:w:bdsviS:P:")) != -1) {
#else
	while ((opt = getopt(argc, argv, "m:t:w:bdsviS:P:")) != -1) {
#endif
#endif
		switch(opt) {
			case 'v': 
				verbose_flag = 1;
				break;
			case 'i': 
				spin_flag = 1;
				break;
			case 'm': 
				mmap_file_name = strdup(optarg);
				break;
			case 't':
				trace_file_name = strdup(optarg);
				break;
			case 'w':
				reg_write_file_name = strdup(optarg);
				long_reg_write_file_name = calloc(1, (strlen(reg_write_file_name)+8)*sizeof(char));
				sprintf(long_reg_write_file_name, "%s.long", reg_write_file_name);
				log_flag = 1;
				break;
			case 'S':
				logger_server_ip_address = strdup(optarg);
				log_flag = 1;
				break;
			case 'P':
				logger_server_port_number = atoi(optarg);
				log_flag = 1;
				break;
#ifdef GDB
			case 'p':
				strcpy(port_number,optarg);
				break;
#endif
#ifdef DOVAL
			case 'r':
				results_file_name = strdup(optarg);
				break;
			case 'l':
				log_file_name = strdup(optarg);
				break;
#else

			case 'b':
				run_bist = 1;
				break;
			case 'd': 
				debug = 1;
				break;
#endif
			case 's': 
				single_step = 1;
				break;
			default: 
				fprintf(stderr,"Error: unknown option %c\n", opt);
				break;
		}
	}

	FILE* mmap_file = fopen(mmap_file_name,"r");
	if(!mmap_file)
	{
		fprintf(stderr,"\n ERROR: file %s cannot be opened!\n",mmap_file_name);
		return(1);
	}
	else
	{
		fclose(mmap_file);
	}
#ifdef GDB
	if (port_number[0] == '\0')
	{
		fprintf(stderr,"\nERROR: port number is not specified!\n");
		return(1);
	}
#endif

				
	if(trace_file_name != NULL)
	{
		if(strcmp(trace_file_name,"stderr") == 0)
		{
			trace_file = stderr;
		}	
		else if(strcmp(trace_file_name,"stdout") == 0)
		{
			trace_file = stdout;
		}	
		else 
		{
			trace_file = fopen(trace_file_name,"w");
			if(trace_file == NULL)
				fprintf(stderr,"Warning: trace-file not found, no trace will be dumped.\n");
		}
	}

	// register-write logging
	if(reg_write_file_name!= NULL)
	{   
		reg_write_file = fopen(reg_write_file_name,"w");
		long_reg_write_file = fopen(long_reg_write_file_name,"w");

		if(reg_write_file == NULL)
			fprintf(stderr,"Warning: register-writes-trace-file not found, no trace will be dumped.\n");
		else
		{
			fprintf(reg_write_file,"//============== Aa-model/FPGA-model register-write trace =============\n");
			fprintf(reg_write_file,"//=====================================================================\n");
		}
	} 

	// set to 1 to generate pipe-handler log..
	debug = 0;
#ifdef USE_PIPE_HANDLER
	if(debug)
		init_pipe_handler_with_log("pipe_handler.log");
	else
		init_pipe_handler();
#endif

	int sw_flag =1; // environmennt is fully in software...
	// start environment (other threads such as memory, IO drivers)
	// the function should return 1 on success.


	if(cpu_env_model(mmap_file_name, LOG_OF_MEMORY_SIZE, 
				sw_flag,// software flag
				0, 	// display-driver
				0, 	// use-kbd-driver
				verbose_flag,
				trace_file // for logging of execution traces.
			)!=1) 
		return(1);

	
	// need some delay?
	__SLEEP__(1000);	

#ifdef CONNECTRIFFA
	// riffa listener interface
	fprintf(stderr,"Starting Riffa Interface Daemons.\n");
	cetr_start_daemons();
#endif 

#ifdef proto_board
	//Initialize memory using a memory map file
	if(initialize_Memory(mmap_file_name)!=1) 
		return(0);
#endif 
	
	// write 1 to reset.
	//  before the daemons are started.
	write_uint8("ENV_to_AJIT_reset", 1);

#ifdef GDB
	start_gpb_threads();
#endif
#ifdef SW
	// start the core... Note it is in reset
	sys_core_start_daemons(trace_file);
#endif

	// start draining pmode.
	PTHREAD_DECL(listenToPmode);
	PTHREAD_CREATE(listenToPmode);

	// wait until all daemons have
	// started..
	__SLEEP__(100000);

#ifndef GDB
	// Connect to the debug_unit first
	write_uint32("ENV_to_AJIT_debug_command", 0x010E0000);		// Send manual connect request
	uint32_t resp_msg = read_uint32("AJIT_to_ENV_debug_response");		// Recieve back 'OK'
#endif
	
	putTheProcessorInReset();

	// check for dangling pipes.
	check_for_dangling_pipes();

	// bring CPU out of reset.
	// bit-0 is hard-reset. 	
	uint8_t bit0=0;
	// bit-1 is debug-mode.	
	uint8_t bit1=0;

#ifdef GDB
	bit1=1;
#endif

	// bit-2 is single-step mode.
	uint8_t bit2=0;
	if(single_step) bit2=1;
	//bit3 is logging-enabled.
	uint8_t bit3=0;
	if(log_file_name) bit3=1;
	uint8_t reset_value = (bit3<<3)|(bit2<<2)|(bit1<<1)|bit0;
	write_uint8("ENV_to_AJIT_reset",reset_value); 
	fprintf(stderr,"processor brought out of reset-mode. Debug-mode=%d, Single-step-mode=%d, Logging-enabled=%d\n",bit1,bit2,bit3);

	// get run time
	start_t = time(NULL);
	// listen for CPU error
	checkErrorStateAndExit();
	end_t = time(NULL);

	total_t = end_t - start_t;
	fprintf(stderr,"Total time taken by CPU: %ld secs\n", total_t);

	if(spin_flag)
	{
		while(1) 
		{
			fprintf(stderr,"\n: Error state: type ctrl-C to kill.\n");
			usleep(10000000);
			if(interrupted_flag)
				break;
		}
	}

#if !defined(DOVAL) && !defined(GDB)
	//
	// processor is in error state.
	// CCU will loop for-ever. let it loop.
	// dump state.
	//
	//
	if(trace_file != NULL)
	{
		uint32_t psr_val = dbg_dump_iunit_state_registers(trace_file);
		dbg_dump_iunit_gp_registers(psr_val, trace_file);
		dbg_dump_fpunit_registers(trace_file);
		dbg_dump_memory(10, 0, 16, trace_file);
	}
#endif

#ifdef DOVAL
	fprintf (stderr, "\n\nValidating : Result file = %s, Log file = %s\n", results_file_name, log_file_name);
	
	main_ret_val = doval (results_file_name, log_file_name);
	if(main_ret_val == 0)
		fprintf(stderr, "\n\nTests Successful.\n");
	else
		fprintf(stderr, "\n\nERROR: Tests Failed.\n");
	
#endif

#ifdef SW
	// stop core
	sys_core_stop_daemons();
#endif
#ifdef GDB
	// stop gdb server bridge
	stop_gpb_threads();
#endif
#ifdef CONNECTRIFFA
	// shut down riffa listener interface
	cetr_stop_daemons();
#endif 

#ifndef DOVAL
	// why does this crash in the doval case?
	// the debug daemon is still running away
	// (it needs to be added to stop-daemons).
	if((trace_file != NULL) && (trace_file != stderr) && (trace_file != stdout))
		fclose(trace_file);
#endif

	PTHREAD_CANCEL(listenToPmode);
	return (main_ret_val);
}

