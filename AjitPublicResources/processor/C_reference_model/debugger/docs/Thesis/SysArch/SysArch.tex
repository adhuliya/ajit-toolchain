% System Architecture

The proposed system with integrated hardware-software architecture provides a non-intrusive view of the processor and the ability to remotely modify it at any instant. It has a software subsystem with the standard interface of GNU Debugger (GDB)\cite{gdbManual} that communicates with processor hardware. The other part is a hardware subsystem consisting of additional modules with the processor core for supporting these debug commands from the user.

\section{Software subsystem on host}
The software subsystem provides sophisticated debugging options to the user with an intuitive interface. As shown in Figure \ref{SysArch} it consists of two main components. GDB is chosen as the user end debugging utility because of the open source nature and acceptance among software developers. It offers extensive facilities for tracing and altering the execution of programs across different architectures and programming languages. The debugging information will be added to the object file if appropriate options are used for compiling. These details could be the correspondence between the lines of source code and the executable code , and the memory address of all the variables. GDB has to be provided with the same executable running on the AJIT processor, but compiled with debug flags.

The other part of software subsystem is a server bridge that pretends to be the processor hardware for GDB and then translates its complex messages into a simple set of commands to be sent over to the hardware. The software server bridge and GDB could be running on different computers, and their communication link is termed as \textit{RSP interface}. Server bridge allows the users to choose the type of physical connection to be used for \textit{Hardware debug link} that connects it to the AJIT processor.

% Architecture figure
\begin{figure}[h!]
	\centering
	\def\svgwidth{0.7\columnwidth}
	\import{Figs/Architecture/}{Architecture.tex}
	\caption{In-system debugger : System architecture}
	\label{SysArch}
\end{figure}

\subsection{GNU Debugger (GDB)}
The GNU Debugger\footnote{https://www.gnu.org/software/gdb/} (GDB) is a standard open source debugger extensively used by software developers. It allows users to view and control the execution of other programs and is released under GNU General Public License (GPL)\footnote{https://www.gnu.org/licenses/} .

% GDB
\subsubsection{Functionalities and usage}
GDB allows the users to monitor and modify the values of programs' internal variables, and even call functions independently of the program's normal behaviour. Tracing the program execution and altering the hardware state at any instant becomes very easy with GDB. It offers quite a lot of functionalities, mainly the following four with a few other supporting ones.
\begin{itemize}
	\item Start the program by specifying all the details for running
	\item Stop the program execution on certain conditions like break-points, watch-points, exceptions etc. and advance only when user instructs so
	\item Examine / modify the register \& memory contents while the execution is stopped temporarily
	\item Change values and conditions in the program, to experiment and figure out the possible reasons for bug
\end{itemize}

GDB can debug programs running on the same machine (native), or on another machine (remote). In remote debugging, GDB runs on a normal full fledged computer (termed as \textit{Host}) and program gets executed on a smaller machine (termed as \textit{Target}) and they communicate using the Remote Serial Protocol (RSP)\cite{gdbEmbecosm}. The communication interface between the two machines could be a serial line, or an IP network using TCP or UDP as the underlying protocol. Most of the embedded system debugging is done remotely, and the same will be used in the proposed architecture.

\subsubsection{Remote Debugging}
Remote debugging is used to debug programs running on machines that cannot run GDB in the standard way or smaller systems without the resources to run full-featured debugger on it. The GDB on host machine requires a copy of the program (which is to be debugged) executable with all the debug symbols generated by the compiler. Target machine can be configured to communicate in two different methods:

\begin{itemize}
	\item \textbf{Using gdbserver} : This is a much smaller version of the standard GDB that helps to connect the target hardware with the host and communicate. It needs an underlying operating system on the target hardware to work.
	
	\item \textbf{Using debug stubs} : Debug stubs are a collection of files containing special function subroutines that support GDB remote serial protocol on the target. All the services provided by stubs can also be implemented as dedicated hardware modules on target, as being done in this work.
\end{itemize}

% RSP Protocol
\subsection{Remote Serial Protocol (RSP) interface}

The RSP interface existing between GDB and the software server bridge uses the same RSP data transfer scheme used for communicating with remote targets. Instead of the actual hardware, here a moderator program receives all the RSP commands and responds back.

% RSP packet figure
\begin{figure}[h!]
	\centering
	\def\svgwidth{0.8\textwidth}
	\import{Figs/RSPpacket/}{RSPpacket.tex}
	\caption{RSP packet format}
	\label{RSPpacket}
\end{figure}

All the communication interfaces supported by GDB could potentially be used here for RSP interface. Here the GDB on the host side acts as RSP client for the software server bridge. Client can send requests to the server as packets, expecting values or acknowledgement message in return. The format of a single RSP packet is shown in Figure \ref{RSPpacket}.

Here \$ and \# function as the head and tail characters respectively. The 8-bit checksum is calculated as modulo 256 of unsigned sum of all characters in the packet, and represented by a pair of hexadecimal digits. Each packet is acknowledged by a '+' on satisfactory reception  and '-' to request a re-transmission. The packets can be categorized into three different categories.

\begin{enumerate}
	\item Expecting no response message.
	\item Requires simple acknowledgement messages or error code.
	\item Expects only data in the response packet.
\end{enumerate}

% GDB remote communications
\vspace*{65mm}
\begin{figure}[h!]
	\def\svgwidth{55mm}
	\hspace{3cm}
	\import{Figs/GDBcommunicate/}{GDBcommunicate.tex}
	\caption{RSP packet exchange}
	\label{gdbRSP}
\end{figure}

Each command entered by user in GDB on the host machine is actually mapped to multiple RSP commands for carrying out corresponding operation. An example RSP communication of connection establishment is shown in Figure \ref{gdbRSP}. The simple command on GDB triggers a series of RSP communication between the client and server. 

First of all the client (GDB on host) requests the maximum packet size supported through the link. Second query is to know why the target halted, and verify that it did not happen because of an terminate command (X) or exited (W). Then it send a \texttt{qC} command, to get the information about the thread being executed. \texttt{qOffset} requests the memory offsets for loading binary data. Then the values of all registers are requested by \texttt{g} command. Finally the target will provide any symbolic data as per the request from host.

All the standard RSP packets are supported by the proposed in-system debugger and they are described in Appendix \ref{appRSP}.


% Software server bridge
\subsection{Software server bridge}
Software server bridge program runs indefinitely on the host machine and acts as a translator between the GDB and the AJIT processor. The server continuously listens on the RSP interface expecting GDB message packets which are then processed to retrieve the underlying information. Based on the decoded message, the software server bridge will generate commands for the hardware and send them. Now it will wait for a valid response from the target which then has to be encoded in RSP packet format and sent to GDB. If the server bridge receives an invalid RSP command, then it will reply back immediately.

The standard RSP protocol is very complex and contains a lot of commands that server needs to understand and support. It is partly because the GDB is designed to support different types of hardware and the functionalities have been greatly improved by the open source community. But, here the target hardware is fixed and a lot of these GDB commands can be filtered and simplified further. The software server bridge carries out this filtering and simplification operation. Communication with the actual hardware is can be limited for the necessary set of GDB requests. Essentially the server bridge takes care of all the following tasks.

\begin{description}
	\item \textbf{1. RSP connection :} Establish connection with GDB using the type of RSP interface the user has selected.
	
	\item \textbf{2. Packet reception and decoding :} Receive and decode the RSP packets sent by GDB. Message content extraction and checksum verification are done for all the RSP packets. If the command does not require any information from hardware, then the reply is sent back immediately and if not, further levels of translation are required. The messages could be
	
	\begin{enumerate}
		\item Unsupported commands that will be replied with an empty packet (\$\#00) to indicate they are invalid.
		\item Commands that could always get a constant response from AJIT processor will be  directly replied back by the server bridge itself.
		\item The third type commands requires actual data from the hardware.
	\end{enumerate}
	
	\item \textbf{3. Translation to debug link commands :} The third type of commands mentioned above are translated into single or multiple debug link commands.
	
	\item \textbf{4. debug link connection :} The final task is to pass the commands over the debug link and read the responses back if necessary.
\end{description}

The algorithm of software server bridge is given in Algorithm \ref{ssb_algo}.
\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{ssb\_daemon}{}
			\State $rsp\_interface \gets$ user input
			\State $debug\_link\_type \gets$ user input
			\State \Call{rsp\_connect}{$rsp\_interface$}\Comment{Connect to the RSP interface}
		\While{$rsp\_msg\not=CONNECT$}\Comment{Wait till GDB connects}
			\State $rsp\_msg\gets recv\_rsp\_interface$	
		\EndWhile
		
		\State $send\_rsp\_interface \gets$ \Call{debug\_link\_connect}{$debug\_link\_type$} \Comment{HW connect}
		
		\While{true}\Comment{Infinite loop}
			\State $rsp\_msg\gets recv\_rsp\_interface$\Comment{generate response for RSP command}
			\State $rsp\_msg\_decoded \gets$ \Call{rsp\_decode}{$rsp\_msg$}
			\If{type($rsp\_msg\_decoded$) = hardware\_dependant}
				\State $dbg\_lnk\_msg \gets$ \Call{rsp\_to\_debug}{$rsp\_msg\_decoded$}
				\State $debug\_link\_reply \gets$ \Call{send\_debug\_link\_and\_get\_response}{dbg\_lnk\_msg}
			\ElsIf{type($rsp\_msg\_decoded$) = standard}
				\State $debug\_link\_reply \gets$ \Call{standard\_reply}{$rsp\_msg\_decoded$}
			\Else 
				\State $debug\_link\_reply \gets$ INVALID
			\EndIf
			
			\State $send\_rsp\_interface \gets $ \Call{debug\_to\_rsp}{$debug\_link\_reply$}
		\EndWhile
		
		\EndFunction
	\end{algorithmic}
	\caption{Software server bridge}\label{ssb_algo}
\end{algorithm}

% Hardware debug link
\subsection{Hardware debug link}
The debug link between the software server bridge and the target hardware is treated as a standard serial communication link for simplicity. Different physical connections and protocols could actually be used, but the message format will remain the same. One debug link command could be one, two or three words long depending on its type. Simple commands like \textit{connect} and \textit{detach} requires just a single word, where as memory/register read/write will need 2/3 words.

Each of these packets have one instruction word followed by one or two optional data words. Format of instruction word is shown in Figure \ref{DebugPacket}. First eight bits of the word specifies the total length (1, 2 or 3) of the packet. The next eight bits contains the opcode, and the next 16 bits are interpreted differently for each opcode. All the standard debug link commands are described in Appendix \ref{appDebug}.

% Debug link packet
\begin{figure}[h!]
	\centering
	\def\svgwidth{0.8\textwidth}
	\import{Figs/DebugPacket/}{DebugPacket.tex}
	\caption{Debug link packet : instruction word}
	\label{DebugPacket}
\end{figure}

For the integer unit commands (opcode values 1 or 2), if the reg bit is set then one of the 32 bit general purpose registers (specified by reg-id) is accessed and if any of the other bits are set, then the corresponding special function register will be accessed. In break-point and watch-point commands (opcodes 8,9,10,11) the reg-id can have only values only 0 to 4, limiting the support up to 4 watch-point and break-point registers each. The second command word will specify the data for all register \& memory writes and break-points \& watch-point commands, address for all memory reads and instructions for instruction execution. The third command specifies data for memory writes.

% Hardware subsystem
\section{Hardware subsystem on target}
The commands coming through debug link are executed by the debug supporting units included in the processor hardware. Design of these processor specific units heavily depend on the implementation structure. The AJIT processor development has progressed in two parallel directions to make the verification process easier. The final objective is to create the models of processor at different levels, satisfying the guidelines of SPARC V8 architecture manual\cite{sparcV8}.

First model of the processor is completely implemented in C \cite{sarath} \cite{aneesh} including the caches and MMU, that could execute binaries compiled for SPARC targets. It is an attempt to create a completely verified, ISA level simulator of the architecture to support future developments. The second model description faithfully represents the actual processor hardware including the pipeline. This representation could be converted into the hardware description, simulated and eventually ported to FPGA. Individual blocks of this model can be modified at different levels to improve the overall efficiency. The hardware subsystem was designed for both the models of AJIT processor according to their structure.

\subsection{Hardware subsystem in ISA-C model}
ISA level model of the AJIT processor has all the individual components modelled with parallel threads. There is a testbench that mimics the external environment of the processor, and provide the initial memory map to start the execution. The model also has specific driver functions to read from and write to the standard I/O.

The main CPU core thread implements instruction fetch, decode and execute along with exceptions checks. The implemented memory subsystem contains Virtually Indexed Virtually Tagged (VIVT) instruction and data caches since they are the easiest and fastest design to implement. Model uses paging technique to use virtual memory, and refer a 3-level page table to get mapping of a virtual address. Both TLB and CPU caches are fully associative, with dual port TLB handling request from both instruction and data caches. The primary aim of this model is to work as a simulator for executing SPARC binaries and provide a reference behaviour for the hardware models. The debug support in ISA-C model is provided by a hardware server connected to the processor core as shown in Figure \ref{Cmodel}.

\subsubsection{Hardware server}
The Hardware server receives the debug link commands from the software server bridge. It has the ability to communicate with the processor core and memory separately. When the processor is turned on in debug mode, it will inform the hardware server and wait for a \textit{continue} signal back. The hardware server will now wait for the connection request from GDB and once its established, all subsequent commands (read/write registers, set/clear break-points etc..) will be executed. The hardware server will allow the processor to run when it gets a \textit{continue} message from software server bridge.

% ISA-C model figure
\begin{figure}[h!]
	\centering
	\def\svgwidth{0.45\columnwidth}
	\import{Figs/Cmodel/}{Cmodel.tex}
	\caption{Hardware server on ISA-C model}
	\label{Cmodel}
\end{figure}

In every execution cycle after instruction fetch, processor core will inform the current state and interrupt status to the hardware server and wait for \textit{continue}. Now the hardware server compares the current Program Counter (PC) with all the valid break-point registers and memory address with all the valid watch-point registers. If there is no match, then continue signal is sent right away. Processor continues to write-back the results after getting the continue message. In cases of watch-point or break-point hit, the message is encoded and passed on to the software server bridge. Processor core will inform hardware server in the case of exceptions and interrupts as well. After receiving any such message, server bridge can send commands to view/modify the processor register/memory contents. It can also command the hardware server to set up new break and watch points, which the hardware server stores in one of the 8 local registers.



\subsection{Debug units in micro-architecture model}
The micro-architecture model faithfully represents the actual processor hardware including the pipeline. It has three main parts : CPU Control Unit (CCU), Thread Execution Unit (TEU) and Memory Interface Unit (MIU).  They are shown in Figure \ref{Aamodel} and described below.

\begin{description}
	\item \textbf{1. CPU Control Unit :} When the processor is powered on, the control will be with the CPU Control Unit (CCU). The processor can be ran in normal or debug or single step mode based on the reset value provided. After initializing the processor registers, CCU transfers control (along with the current PC, NPC values) to the TEU.
	
	CCU will obtain the control back only when exception occur in the TEU. Then it will execute the trap handler and inform the TEU to stop fetching further instructions. After the CCU completes its part, TEU is allowed to continue execution and provided with PC, NPC values. CCU sends out the current processor mode every cycle for the testbench to check if it has entered the error mode.
	
	\item \textbf{2. Thread Execution Unit :} TEU is essentially the actual processor pipeline that decides the actual processor throughput. It starts execution when the CCU hands over the PC, NPC set. The model has an elastic pipeline with subsequent stages connected using interlocking FIFOs (AHIR-V2 pipes) independent of any timing assumptions as shown in Appendix \ref{appTEU}.
	
	Instructions in execution stage could be out of order, but they get ordered at the retire stage, making this an in-order pipeline. All instructions are given an 8-bit slot id by the fetch stage to preserve the order. Checks for interrupts are done during instruction fetch and all the load/store operations are strictly maintained to be in order. All exceptions are treated as precise, which requires all blocks to be synchronized. Exceptions occurring at intermediate stages of pipeline are passed on to the retire stage and finally to CCU. All the subsequent instructions will pass through the pipeline without altering the processor state. Finally, the execution will continue normally when the CCU hands over a new set of PC, NPC values.
	
	\item \textbf{3. Memory Interface Unit :} MIU is just the interface for the processor to read / write data from / to the main memory.
\end{description}


% Aa model figure
\begin{figure}[h!]
	\centering
	\def\svgwidth{0.8\columnwidth}
	\import{Figs/Aamodel/}{Aamodel.tex}
	\caption{Debug units in micro-architecture model}
	\label{Aamodel}
\end{figure}

The CCU and TEU were modified and two additional modules were added to the processor for supporting the debug functionalities proposed in this work and the final system is shown in Figure \ref{Aamodel}. The Debug interface unit is added to receive messages through the debug link, decode all the valid commands and generate their response. The break-point \& watch-point related requests are handled by the the TEU debug unit and the rest by CCU.

\subsubsection{Debug interface unit}
The debug interface unit receive all the messages coming through the debug link and send the responses back. It filters out all the break-point and watch-point related messages and forward them to the TEU debug unit. All the watch-point registers values are also locally stored. The requests for memory/register read/write operations are passed on to the CCU. Their responses are then sent back to the software server bridge through the debug link. When there is a break-point or watch-point hit, trap occurrence, interrupt etc.. the debug interface will be informed by the CCU for passing it on to the software server bridge. In cases of a watch-point hit, its stored address will also be sent as a second the packet.

\begin{algorithm}
	\caption{Debug interface unit}\label{dbg_interface_dmn}
	\begin{algorithmic}[1]
	\Function{debug\_interface\_daemon}{}
	\While{$ccu\_msg\not=CONNECT$ or $gdb\_msg\not=CONNECT$}\Comment{CCU, GDB connect}
	\State $ccu\_msg \gets ccu\_to\_debug\_pipe$
	\State $gdb\_msg\gets debug\_link\_in$		
	\EndWhile\label{dummy}
	\State $debug\_to\_ccu\_pipe, debug\_link\_out \gets Acknowledge\_OK$
	
	\While {1}\Comment{Infinite loop}
		\State $ccu\_msg \gets ccu\_to\_debug\_pipe$ \Comment{Message from CCU}
		\If{(ccu\_msg is valid)}
		\State Decode ccu\_msg
			\If{(breakpoint or watchpoint or trap hit or interrupt)}
				\State $stored\_PC, stored\_NPC, stored\_PSR \gets ccu\_to\_debug\_pipe$
			\EndIf
	
		\State $debug\_link\_out \gets $ Encode $ccu\_msg$ for GDB
			\If{(watchpoint(x) hit)}
				\State $debug\_link\_out \gets $ stored adddress of x
			\EndIf
		\EndIf	
		\State $gdb\_msg \gets debug\_link\_in$	\Comment{Message from Debug link}
		\If{($gdb\_msg$ is valid)}
			\State Decode $gdb\_msg$
			\State $debug\_to\_ccu\_pipe \gets gdb\_msg$
			\If{(msg\_length = 2)}
				\State $gdb\_msg\_2 \gets debug\_link\_in$	
				\State $debug\_to\_ccu\_pipe \gets  gdb\_msg\_2$
			\EndIf
			\If{(msg\_length = 3)}
				\State $gdb\_msg\_3 \gets debug\_link\_in$	
				\State $debug\_to\_ccu\_pipe \gets  gdb\_msg\_3$
			\EndIf	
			\If{(PC or NPC or PSR write)}
				\State $stored\_PC$ or $stored\_NPC$ or $stored\_PSR$ $\gets gdb\_msg\_2$
				\ElsIf{(watchpoint(x) write)}
				\State stored adddress of x $\gets gdb\_msg\_2$
			\ElsIf{(read the memory / register)}
				\State $ccu\_data \gets ccu\_to\_debug\_pipe$
				\State $debug\_link\_out \gets ccu\_data$
			\ElsIf{(CONTINUE or DETACH)}
				\State $debug\_to\_ccu\_pipe \gets stored\_PC, stored\_NPC, stored\_PSR$
			\EndIf
	
			\If{((set/clear the breakpoint/watchpoint) or (write memory / register))}
				\State $debug\_link\_out \gets Acknowledge\_OK$
			\EndIf
		\EndIf
	\EndWhile
	\EndFunction
\end{algorithmic}
\end{algorithm}

 Details of the unit are given in Algorithm \ref{dbg_interface_dmn}. Every time the CCU stops and the debug interface is notified, the current values of Program Counter (PC), Next Program Counter (NPC), and Program Status Register (PSR) values are also send along with it. The debug interface unit locally stores these values and modifies them if user requests so. Finally when it receives a \textit{continue} message, the debug interface sends back the their updated values to the CCU.
 
 \subsubsection{Modified CCU}
 The CCU is modified as given in Algorithm \ref{ccu} to support the debug operations. Now it has to be stopped initially (for connecting with debug interface unit), on hitting watch-points/break-points, on interrupts, and other exceptions for transferring the control over to the interface unit. The commands of register/memory read and write from the software server bridge are executed by the CCU when it is stopped. Finally when the CCU receives a \textit{continue} message, it resumes execution and the control is finally passed on to the TEU. CCU has separate connections to the TEU for reading and modifying the register contents, and to MIU for reading and modifying the memory contents.
 
 \begin{algorithm}
 	\caption{CCU}\label{ccu}
 	\begin{algorithmic}[1]
 		\Function{CPU\_CCU}{}
 		\State $debug\_mode \gets ENABLE$
 		\State Initialize processor
 		\State $ccu\_to\_debug\_pipe \gets CONNECT$
 		\While{$debug\_msg \not= Acknowledge\_OK$}\Comment{Establish connection with debugger}
 		\State $debug\_msg\gets debug\_to\_ccu\_pipe$	
 		\EndWhile
 		\State \Call{CCUrespondToGDB}{GDB\_CONNECTED,0}\Comment{Execute GDB commands}
 		\While{1}\Comment{Infinite loop}
	 		\State ...
	 		\If{(error\_mode)}
	 		\State \Call{CCUrespondToGDB}{ERROR\_MODE,0}
	 		\EndIf
	 		\State ...
	 		\If{(trap) and ($debug\_mode$ = $ENABLE$)}
	 		\State \Call{CCUrespondToGDB}{TRAP,0}
	 		\EndIf
	 		\State ...
	 		\State $pass\_to\_teu \gets 1$
	 		\While{$pass\_to\_teu$}
	 		\State $ccu\_to\_teu \gets CONTINUE$
	 		\State $teu\_msg \gets teu\_to\_ccu\_pipe$\Comment{wait till TEU send back a response}
	 		\algstore{myalg2}
	 	\end{algorithmic}
	 \end{algorithm}
	 
	 \begin{algorithm}
	 	\begin{algorithmic}
	 		\algrestore{myalg2}
	 		\If{(breakpoint hit) and ($debug\_mode$ = $ENABLE$)}
	 		\State \Call{CCUrespondToGDB}{BP\_HIT,reg} 		
	 		\ElsIf{(watchpoint hit) and ($debug\_mode$ = $ENABLE$)}
	 		\State \Call{CCUrespondToGDB}{WP\_HIT,reg}
	 		\ElsIf{(interrupt) and ($debug\_mode$ = $ENABLE$)}
	 		\State \Call{CCUrespondToGDB}{INTR,0}
	 		\Else
	 		\State $pass\_to\_teu \gets 0$
	 		\EndIf
	 		\EndWhile
 		\EndWhile
 		\EndFunction
 		
 		\Function{CCUrespondToGDB}{stop\_reason,reg}
 		\State $ccu\_to\_debug\_pipe \gets $ Encode (stop\_reason,reg) for debugger
 		\If{( stop\_reason = breakpoint or watchpoint or trap hit or interrupt)}
 		\State $ccu\_to\_debug\_pipe \gets PC, NPC, PSR$
 		\EndIf
 		\State $debug\_msg \gets debug\_to\_ccu\_pipe$
 		\While{$debug\_msg \not= CONTINUE$}\Comment{Execute GDB commands till CONTINUE}
 		\State Decode $debug\_msg$ 		
 		
 		\If{(read register x)}
 		\State $ccu\_to\_debug\_pipe \gets $ content of register x
 		\ElsIf{(write register x)}
 		\State content of register x $\gets debug\_to\_ccu\_pipe$
 		\ElsIf{(read memory)}
 		\State $mem\_address \gets debug\_to\_ccu\_pipe$
 		\State $ccu\_to\_debug\_pipe \gets $ content of $mem\_address$
 		\ElsIf{(write memory)}
 		\State $mem\_address \gets debug\_to\_ccu\_pipe$
 		\State $mem\_data \gets debug\_to\_ccu\_pipe$
 		\State content of $mem\_address \gets mem\_data$
 		\ElsIf{(set break-point/watch-point x)}
 		\State $ccu\_to\_teu\_debug\_unit \gets $ Encode (SET, break/watch, x, $debug\_to\_ccu\_pipe$)
 		\ElsIf{(remove break-point/watch-point x)}
 		\State $ccu\_to\_teu\_debug\_unit \gets $ Encode (REMOVE, break/watch, x)
 		\ElsIf{(Interrupt)}
 		\State $ccu\_to\_teu\_debug\_unit \gets $ Encode (Interrupt)
 		\ElsIf{(DETACH)}
 		\State $debug\_mode \gets DISABLE$
 		\State \textbf{break}
 		\EndIf
 		
 		\State $debug\_msg \gets debug\_to\_ccu\_pipe$	
 		\EndWhile
 		
 		\If{($debug\_msg = $ CONTINUE or DETACH)}
 		\State $PC, NPC, PSR \gets debug\_to\_ccu\_pipe$
 		\EndIf
 		
 		\EndFunction
 	\end{algorithmic}
 \end{algorithm}
 
 \newpage
 \subsubsection{TEU Debug unit}
 The commands from debug interface to set or clear the break-points and watch-points are executed by storing them locally in the TEU debug unit.
 During every instruction execution, the PC address is compared with these stored valid break-points. For the memory access instructions, the address will also be compared against the valid watch-points. If either of the checks succeeds or an exception or interrupt occures, the TEU debug unit will inform the retire unit of TEU to stop the program execution and transfer the control back to CCU.  The debug interface can use this unit to interrupt the program execution (TEU) at any instant as per the software server bridge command. More details are given in Algorithm \ref{teu}.
  
 \begin{algorithm}
 	\caption{TEU}\label{teu}
 	\begin{algorithmic}[1]
 		\Function{TEU\_debug\_unit}{}
 		\While{1}\Comment{Infinite loop}
	 		\State $ccu\_command \gets ccu\_to\_teu\_debug\_unit$
	 		\State Decode $ccu\_command$
	 		\If{($ccu\_command = $ set break-point/watch-point x)}
		 		\State break-point/watch-point (x) $\gets ccu\_command\_data$, valid
		 	\ElsIf{($ccu\_command = $ clear break-point/watch-point x)}
			 	\State break-point/watch-point (x) $\gets$ invalid
			\ElsIf {Interrupt}
				\State $teu\_debug\_to\_retire \gets interrupt$
	 		\EndIf
 		
	 		\If{($fetch\_address = $ content of breakpoint register x)}
		 		\State $teu\_debug\_to\_retire \gets $ Breakpoint x hit
	 		\EndIf
	 		\If{($memory\_address = $ content of watchpoint register x)}
		 		\State $teu\_debug\_to\_retire \gets $ Watchpoint x hit
		 	\EndIf
 		\EndWhile
 		\EndFunction
 		
 		\Function{TEU\_main}{}
 		\While{1}\Comment{Infinite loop}
	 		\State $PC, NPC \gets ccu\_to\_teu$
	 		\While{($bp\_wp\_intr$ not hit) and (no exceptions) and (no interrupt)}
		 		\State Instruction fetch \& decode
		 		\State $to\_teu\_debug\_unit \gets fetch\_address, memory\_address$
		 		\State Execute
		 		\State $bp\_wp\_intr \gets teu\_debug\_to\_retire$
		 	\EndWhile
	 	\EndWhile
 		\EndFunction
 	\end{algorithmic}
 \end{algorithm}