# asmgen

Investigating the issues involved in generating the assembler from a given CPU data sheets. This, of course, needs to be further parameterized with respect to the overall target machine and the target toolchain.

The GNU Binutils port of the AJIT processor is done.  It can now assemble the arithmetic and logical insns. However, we need a way to check if the binary instructions that are generated are correct. Hence the "opcode-generator.py" script.  This was started as a C program, but quickly moved to Python.  This Python script is used by the "insn-static-testing.sh" (bash) shell script. The shell script organises the entire exhaustive testing.

The "opcode-generator.py" is a Python 3.x program that takes as input two pieces of information: (a) a description of the instructions (insns, for short) in a CSV file, and (b) a description of possible bit field arrangements in a CSV filer., It then produces a set of instruction codes (printed in hexadecimal and binary formats), and the ASM instruction of that opcode.  This information is used in testing the assembler implementation. Additional useful information is also generated, e.g. the reference to the SPARC V8 manual where a given insn is described. 

The assembler and the disassembler is implemented in the GNU Binutils port for AJIT.  Given an ASM code, the assembler generates (a) the equivalent object code, and (b) a listing of the generation that has the ASM code and its binary representation in hexadecimal. The disassembler is given the object code and it generates the ASM code for each binary representation.

We thus have the binary and hexadecimal representations of ASM code from three sources: (a) the opcode generator script, (b) the assembler from GNU binutils, and (c) the disassembler from GNU binutils. The opcode generator has generated the information from the SPARC V8 manual and the AJIT manual.  If the ASM code from the opcode generator is given to the GNU assembler, then we expect the assembler to generate _exactly_ the same opcode as that generated by the opcode generator.  Similarly we expect the GNU disassembler to obtain almost the same ASM instruction as was input to the assembler (or generated by the opcode generator).  The top level (bash) shell script "insn-static-testing.sh" does exactly that.

The top level shell script does the following:

   (a) Sets up the various testing parameters, in particular the specific assembler + disassembler to be tested.
   (b) Runs the opcode-generator.py script for _each AJIT instruction_. The output is a "|" separated table of opcode in hex, opcode in binary and ASM code.
   (c) Extracts the ASM code from the above.
   (d) Runs the assembler on the ASM code to obtain the (a) object file, and (b) the listing file.
   (e) Runs the disassembler on the object file to obtain the disassembled file which has the opcode in hex and the ASM code.
   (f) Processes the outputs from (a) opcode-generator.py, (b) assembler, and (c) disassembler to obtain the opcode in hex, opcode in binary and ASM code from each.
   (g) For each AJIT instruction, check that the opcode patterns are identical for _all the three_, and label successes as "PASS" and failures as "FAIL".
   (h) Finally, create a summary table of each instruction for an overall "PASS" or "FAIL".



