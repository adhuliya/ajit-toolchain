head	1.1;
access;
symbols;
locks
	amv:1.1; strict;
comment	@# @;


1.1
date	2018.09.25.13.38.46;	author amv;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@;;
;; INSN Language
;;
(load "insn-lang.scm")

;;
;; Simple structure: The grammar is
;;
;; attribute : '(' symbol value ')'
;; structure : () | '(' attribute structure ')'
;; symbol : variable
;; value  : datum | structure
;; datum  : string | number | enumerated | expression
;;

;; insn : () | '(' attribute insn ')'    ; List of attributes
;; attribute : '(' symbol value ')'
;; value : string | integer | enumerated | list

;; Given a description of ONE insn, get the components.
;; This is a generic low level extractor. The individual selectors are
;; separately defined.

;; Flattens nested lists
(define flatten
  (lambda (l)
    (if (null? l) l
	(append (car l)
		(flatten (cdr l))
		))))

(define amv-reverse
  (lambda (l)
    (append (reverse (cdr l)) (list (car l)))))


(define get
  (lambda (insn-data info-symbol)
    (if (null? insn-data)
	insn-data
	(let ((info     (car insn-data))
	      (rest     (cdr insn-data)))
	  (if (and (list? info) (= (length info) 2))
	      (let ((sym   (car  info))
		    (val   (cadr info)))
		(if (eqv? sym info-symbol)
		    val
		    (get rest info-symbol))
		)
	      #f
	      )
	  ))
    ))

;; stors (SelecTORS)
(define get-insn-mnemonic
   (lambda (insn) (get insn 'mnemonic)))

(define get-insn-insn-subtype
   (lambda (insn) (get insn 'insn-subtype)))

(define get-insn-alignment-type
   (lambda (insn) (get insn 'alignment-type)))

(define get-insn-length-in-bits 
   (lambda (insn) (get insn 'length-in-bits )))

(define get-insn-format-type
   (lambda (insn) (get insn 'format-type)))

(define get-insn-bit-order
   (lambda (insn) (get insn 'bit-order)))

(define get-insn-opcode-layout
   (lambda (insn) (get insn 'opcode-layout)))

(define get-number-of-all-regions-in-insn
  (lambda (insn) (length (get-insn-opcode-layout insn))))

(define get-number-of-given-region-type-in-insn
  (lambda (insn type)
    (let ((num-regions   (get-number-of-all-regions-in-insn insn))
	  (regions-list  (get-insn-opcode-layout            insn)))
      (define process-regions-list
	(lambda (rl)
	  (if (null? rl)
	      0
	      (let ((curr-region   (car rl))
		    (rest-region   (cdr rl))
		    )
		(+ (if (eq? (car curr-region) type) 1 0)
		   (process-regions-list rest-region)))
	      )))
      (process-regions-list regions-list))))

(define get-number-of-unions-in-insn
  (lambda (insn)
    (get-number-of-given-region-type-in-insn insn 'union)))

(define get-number-of-regions-in-insn
  (lambda (insn)
    (get-number-of-given-region-type-in-insn insn 'region)))

(define get-list-of-given-region-type-in-insn
  (lambda (insn type)
    (let ((num-regions   (get-number-of-all-regions-in-insn insn))
	  (regions-list  (get-insn-opcode-layout            insn)))
      (define process-regions-list
	(lambda (rl)
	  (if (null? rl)
	      rl
	      (let ((curr-region   (car rl))
		    (rest-region   (cdr rl))
		    )
		(if (eq? (car curr-region) type)
		    (cons curr-region 
			  (process-regions-list rest-region))
		    (process-regions-list rest-region))
	      ))))
      (process-regions-list regions-list)
      )))

(define get-list-of-unions-in-insn
  (lambda (insn)
    (get-list-of-given-region-type-in-insn insn 'union)))

(define get-list-of-regions-in-insn
  (lambda (insn)
    (get-list-of-given-region-type-in-insn insn 'region)))

(define get-list-of-regions-in-union
  (lambda (u) (cadar u)))

;;
;; Return a list of pairs, each pair given as: (binary digit . location).
;; 
    (define get-val-of
      (lambda (region-details-list sym)
	(if (null? region-details-list)
	    '()
	    (let* ((bind    (car  region-details-list))
		   (rest    (cdr region-details-list))
		   (the-sym (car  bind))
		   (the-val (cadr bind))
		   )
	      (if (eq? the-sym sym)
	      	  the-val
	      	  (get-val-of rest sym))))))

    (define get-list-of-binary-digit-and-location-pairs
      (lambda (value start end)
	(if (> start end) '()
	    (let* ((least-digit   (if (number? value)
				      (remainder value 2)
				      'X))
		   (next-value    (if (number? value)
				      (quotient  value 2)
				      'X))
		   )
	      (cons (cons least-digit start)
		    (get-list-of-binary-digit-and-location-pairs
		     next-value
		     (+ start 1)
		     end)
		    )
	      )				; end let
	    )
	)
      )

;;
;; A union describes the same set of bits organized in different ways.
;; An organization  is a set of  one or more regions.   We expand each
;; organization into a list of bit patterns.  A bit pattern of a union
;; is a list of bit patterns of each organization.
;; 
(define get-bit-pattern-lists-of-all-unions
  (lambda (lou)
    (if (null? lou) '()
	(let* ((curr-union       (car    lou))
	       (curr-union-list  (cadr   curr-union))
	       (rest-unions      (cdr    lou)))
	  (cons (get-bit-pattern-lists-of-one-union   curr-union-list)
		(get-bit-pattern-lists-of-all-unions  rest-unions))
	  ))))

;; Return a list of bit patterns of union for each organization.
(define get-bit-pattern-lists-of-one-union
  (lambda (loriu)
    (if (null? loriu) '()
	(begin
	  (pp "Given union is: ")
	  (pp loriu)
	  (newline)
	  (let* ((curr-region  (car  loriu))
		 (rest-region  (cdr  loriu))
		 (cr-bits      (get-bit-pattern-list-of-a-region    curr-region)))
	    (begin
	      (pp "Current region is: ")
	      (pp curr-region)
	      (newline)
	      (pp "Rest of the regions are: ")
	      (pp rest-region)
	      (newline)
	      (pp "Bits of current region are: ")
	      (pp cr-bits)
	      (newline)
	      (cons cr-bits
		    (get-bit-pattern-lists-of-one-union  rest-region)
		    ))
	    )
	  )
	)))

(define get-bit-pattern-list-of-a-region
  (lambda (r)
    (if (null? r) r
        (let* ((a-region (car  r))
	       (rest     (cdr  r))
	       (attribs  (cadr a-region))
               (name     (get-val-of attribs 'name))
               (start    (get-val-of attribs 'start))
               (end      (get-val-of attribs 'end))
               (meaning  (get-val-of attribs 'meaning))
               (val-det  (get-val-of attribs 'setup))
               (the-val  (get-val-of val-det 'value))
	       (the-rep  (get-val-of val-det 'value-representation))
	       (the-typ  (get-val-of val-det 'value-type))
	       )
	  (cons (get-list-of-binary-digit-and-location-pairs
		 the-val
		 start
		 end)
		(get-bit-pattern-list-of-a-region rest)
	   )
	  )
     )))

(define	rlst  (get-insn-opcode-layout            insn-description))
(define lor   (get-list-of-regions-in-insn       insn-description))
(define lou   (get-list-of-unions-in-insn        insn-description))
(define xlst  (get-bit-pattern-list-of-a-region  lor))
(define ulst  (get-bit-pattern-list-of-a-region  (caadar lou)))

(define a1 '(((0 . 13)) ((X . 5) (X . 6) (X . 7) (X . 8) (X . 9) (X . 10) (X . 11) (X . 12)) ((X . 0) (X . 1) (X . 2) (X . 3) (X . 4))))
(define a2 '(((1 . 13)) ((X . 0) (X . 1) (X . 2) (X . 3) (X . 4) (X . 5) (X . 6) (X . 7) (X . 8) (X . 9) (X . 10) (X . 11) (X . 12))))


;; (define get-bit-pattern-of-a-region
;;   (lambda (r)
;;     (define get-val-of
;;       (lambda (region-details-list sym)
;; 	(if (null? region-details-list)
;; 	    '()
;; 	    (let* ((bind    (car  region-details-list))
;; 		   (rest    (cdr region-details-list))
;; 		   (the-sym (car  bind))
;; 		   (the-val (cadr bind))
;; 		   )
;; 	      (if (eq? the-sym sym)
;; 	      	  the-val
;; 	      	  (get-val-of rest sym))))))

;;     (if (null? r) r
;;         (let* ((a-region (car  r))
;; 	       (attribs  (cadr a-region))
;;                (name     (get-val-of attribs 'name))
;;                (start    (get-val-of attribs 'start))
;;                (end      (get-val-of attribs 'end))
;;                (meaning  (get-val-of attribs 'meaning))
;;                (val-det  (get-val-of attribs 'setup))
;;                (the-val  (get-val-of val-det 'value))
;; 	       (the-rep  (get-val-of val-det 'value-representation))
;; 	       (the-typ  (get-val-of val-det 'value-type))
;; 	       )
;; 	  (begin
;; 	    (display "Name: ")
;; 	    (display name)
;; 	    (newline)

;; 	    (display "Start address of region: ")
;; 	    (display start)
;; 	    (newline)

;; 	    (display "End address of region: ")
;; 	    (display end)
;; 	    (newline)

;; 	    (display "Meaning: ")
;; 	    (display meaning)
;; 	    (newline)

;; 	    (display "Value details: ")
;; 	    (display val-det)
;; 	    (newline)

;; 	    (display "Value: ")
;; 	    (display the-val)
;; 	    (newline)

;; 	    (display "Representation: ")
;; 	    (display the-rep)
;; 	    (newline)

;; 	    (display "Type: ")
;; 	    (display the-typ)
;; 	    (newline)

;; 	    )
;; 	  )
;;      )))

;; (define get-num-regions-in-bits-layout
;;   (lambda (l)
;;     (if (null? l) 0
;; 	(let ((fst    (car l))
;; 	      (rest   (cdr l)))
;; 	  (if (eq? (car fst) 'union)
;; 	      (let* ((unions-lst     (cdr fst))
;; 		     (num-unions     (length unions-lst))
;; 		     )
;; 		(define process-unions
;; 		  (lambda (l)
;; 		    (if (null? l) 0
;; 			(+ (get-num-regions-in-bits-layout (car l))
;; 			   (process-unions (cdr l)))
;; 			)))
;; 		(+ (process-unions unions-lst)
;; 		   (get-num-regions-in-bits-layout rest))
;; 		)
;; 	      (+ 1 (get-num-regions-in-bits-layout rest))
;; 	      )
;; 	  )
;; 	)
;;     )
;;   )

;; (define process-one-region
;;   (lambda (region)
;;     (
;;      )
;;     )
;;   )

;; (define emit-opcode-bit-pattern
;;   (lambda (len)				; typically len is "32" at call!
;;     (let ((bit-pattern  (make-vector len 0)))
;;       (lambda (l)
;; 	(if (null? l) #t


;; 	    (let ((curr-region   (car l))
;; 		  (rest-region   (cdr l)))
;; 	      (if (eq? (car curr-region) 'union)
;; 		  (let* ((unions-lst     (cdr curr-region))
;; 			 (num-unions     (length unions-lst))
;; 			 )
;; 		    (define process-unions
;; 		      (lambda (l)
;; 			(if (null? l) 0
;; 			    (+ (get-num-regions-in-bits-layout (car l))
;; 			       (process-unions (cdr l)))
;; 			    )))
;; 		    (+ (process-unions unions-lst)
;; 		       (get-num-regions-in-bits-layout rest-region))
;; 		    )
;; 		  (+ 1 (get-num-regions-in-bits-layout rest-region))
;; 		  )
;; 	      )


	    
;; 	    )
;; 	)
;;       )
;;     )
;;   )




@
