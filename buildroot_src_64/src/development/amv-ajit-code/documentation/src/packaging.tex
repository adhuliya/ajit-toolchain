\chapter{Packaging AJIT Within BuildRoot System}
\label{chap:amv:packaging:work}

\section{List and Sequence of Files}
\label{sec:packaging:config:list:seq}

Basic directory structure:

\begin{tabular}[h]{|p{.3\textwidth}|p{.7\textwidth}|}
  \hline
  \textbf{VARIABLE NAME} & \textbf{DESCRIPTION} \\
  \hline
  \texttt{TOP} & Some top level directory of buildroot software.\\
  \texttt{BUILDROOT\_VERSION} & \texttt{2014.08}\\
  \texttt{BUILDROOT\_TOP} & \texttt{\$\{TOP\}/buildroot-\$\{BUILDROOT\_VERSION\}}\\
  \texttt{OUTPUT} & \texttt{\$\{BUILDROOT\_TOP\}/output}\\
  \texttt{BUILD} & \texttt{\$\{OUTPUT\}/build}\\
  \hline
\end{tabular}

\begin{enumerate}
\item File  \texttt{\$\{BUILDROOT\_TOP\}/arch/Config.in}: This file is
  used  to add  a  new \emph{architecture}  to the  \texttt{buildroot}
  system.  Add the AJIT processor as follows:
% \codetoadd{
% \begin{verbatim}
% config BR2_ajit
%         bool "AJIT (IIT Bombay)"
%         help
%           Synopsys' IIT Bombay designed SPARC V8 like processor that is
%           targetted for netblazers. Little endian.
% \end{verbatim}
% }
% \framebox{
%   \begin{minipage}[h]{\linewidth}
% \begin{verbatim}
% config BR2_ajit
%         bool "AJIT (IIT Bombay)"
%         help
%           Synopsys' IIT Bombay designed SPARC V8 like processor that is
%           targetted for netblazers. Little endian.
% \end{verbatim}    
%   \end{minipage}
% }

\hrulefill
\begin{verbatim}
config BR2_ajit
        bool "AJIT (IIT Bombay)"
        help
          Synopsys' IIT Bombay designed SPARC V8 like processor that is
          targetted for netblazers. Little endian.
\end{verbatim}    
\hrulefill

The indentation  uses the TAB  character.  It appears to  be mandatory
as every ``\texttt{*/*Config.in}'' file I looked into uses it.

\item \texttt{binutils/gas/configure.tgt}: This is  the file where the
  \texttt{gas}  tool sets  the target  CPU files  given the  usual GNU
  triad (or quad, sometimes).
\end{enumerate}

We  first  focus on  binutils-2.22  for  buildroot-2014.08 only.   The
gdb-7.6.2 port would be similar, and dealt with later.

\section{List and Sequence of Files Processing}
\label{sec:packaging:config:list:seq:processing}

Since  AJIT  is based  on  Sparc  V8, we  first  search  for files  in
\texttt{binutils}  that contain  the  string ``\texttt{sparc}''.   The
search is case insensitive.  We first  focus on adding ajit to the GNU
BFD   system   in   the    binutils.    Hence   our   search   is   in
\texttt{binutils/bfd}.  This yields the following list of files in
tables \ref{tab:bfd:sparc:files:1} and \ref{tab:bfd:sparc:files:2}.

\begin{table}[ht]
  \centering
  \begin{tabular}[h]{|p{.3\linewidth}|p{.7\linewidth}|}
\hline
bfd/aoutf1.h          &  A.out  ``format 1'' file  handling code  for BFD. \\
bfd/aout-sparcle.c    &  BFD backend for sparc little-endian aout binaries. \\
bfd/aoutx.h           &  BFD semi-generic back-end for a.out binaries. \\
bfd/archures.c        &  BFD library support routines for architectures. \\
    \hline
bfd/bfd-in2.h         & 
\begin{minipage}[h]{\linewidth}
  Main  header file  for the  bfd library:  portable access  to object
  files.  This file is automatically generated from

  \begin{tabular}[h]{|l|l|l|}
    \hline 
    ``bfd-in.h'' &    ``init.c'' &    ``opncls.c'' \\
    ``libbfd.c'' &    ``bfdio.c'' &   ``bfdwin.c'' \\
    ``section.c'' &   ``archures.c'' &``reloc.c''  \\
    ``syms.c'' &      ``bfd.c'' &     ``archive.c'' \\
    ``corefile.c'' &  ``targets.c'' & ``format.c'' \\
    ``linker.c'' &    ``simple.c''  &  ``compress.c''\\
    \hline 
  \end{tabular}

  Run ``\texttt{make headers}'' in your build \texttt{bfd/} to regenerate.
\end{minipage} \\
    \hline
bfd/bfd-in.h          &  Main header file for the bfd library:  portable access   to   object   files. \\
bfd/bfd.m4            &  This file was derived from acinclude.m4. \\
bfd/cf-sparclynx.c    &  BFD back-end for Sparc COFF LynxOS files. \\
bfd/coffcode.h        &  Support for the generic parts of most COFF variants, for BFD. \\
bfd/coff-sparc.c      &  BFD back-end for Sparc COFF files. \\
bfd/coff-tic4x.c      &  BFD back-end for TMS320C4X coff binaries. \\
bfd/coff-tic54x.c     &  BFD back-end for TMS320C54X coff binaries. \\
    \hline
bfd/config.bfd        &  
\begin{minipage}[h]{\linewidth}
  Convert  a canonical  host type  into a  BFD host  type.   Set shell
  variable \texttt{targ} to canonical target
  name, and run using ``\texttt{. config.bfd}''. \\
  Sets the following shell variables: \\
  \begin{tabular}[h]{|l|l|}
    \hline
  \texttt{targ\_defvec} &	Default vector for this target \\
  \texttt{targ\_selvecs} &	Vectors to build for this target \\
  \texttt{targ64\_selvecs} &	\parbox{.65\linewidth}{Vectors     to
    build    if \texttt{--enable-64-bit-bfd}  is  given or if host is
    64 bit.} \\ 
  \texttt{targ\_archs} &	Architectures for this target \\
  \texttt{targ\_cflags} &	\texttt{\$(CFLAGS)} for this target (FIXME: pretty bogus) \\
  \texttt{targ\_underscore} &	Whether underscores are used: yes or no \\
    \hline
\end{tabular}
\end{minipage}\\
    \hline
bfd/configure         &  Guess values for system-dependent variables and create Makefiles. \\
bfd/configure.in      &  Process this file with autoconf to produce a configure script. \\
bfd/cpu-sparc.c       &  BFD support for the SPARC architecture. \\
bfd/elf32-cris.c      &  CRIS-specific support for 32-bit ELF.  In comment. \\
bfd/elf32-m68hc1x.h   &  Motorola 68HC11/68HC12-specific support for 32-bit ELF. In comment. \\
bfd/elf32-sparc.c     &  SPARC-specific support for 32-bit ELF. \\
bfd/elf64-ajit.c      &  SPARC-specific support for 64-bit ELF \\
bfd/elf64-sparc.c     &  SPARC-specific support for 64-bit ELF \\
bfd/elf-bfd.h         &  BFD back-end data structures for ELF files. \\
bfd/elf.c             &  ELF executable support for BFD. \\
bfd/elfcode.h         &  ELF executable support for BFD. \\
bfd/elfxx-sparc.c     &  SPARC-specific support for ELF. \\
bfd/elfxx-sparc.h     &  SPARC ELF specific backend routines. \\
bfd/freebsd.h         &  BFD back-end definitions used by all FreeBSD targets. \\
bfd/libaout.h         &  BFD back-end data structures for a.out (and similar) files. \\
  \hline
bfd/libbfd.h          &  
\begin{minipage}[h]{\linewidth}
  Declarations  used by  bfd library  *implementation*.  (This include
  file is not  for users of the library.)   This file is automatically
  generated from
  \begin{tabular}[h]{|l|l|l|}
  \hline
  ``libbfd-in.h'' &    ``init.c'' &     ``libbfd.c'' \\
  ``bfdio.c'' &        ``bfdwin.c'' &   ``cache.c''  \\
  ``reloc.c'' &        ``archures.c'' &  ``elf.c'' \\
  \hline
\end{tabular}
  Run  ``\texttt{make  headers}''  in  your  build  \texttt{bfd/}  to
  regenerate.
\end{minipage} \\
\hline
\end{tabular}
\caption[List of files 1]{List of files in \texttt{binutils/bfd} that
  contain the word ``\texttt{sparc}''.  Continued in
  Table~\ref{tab:bfd:sparc:files:2}.} 
\label{tab:bfd:sparc:files:1}
\end{table}
\begin{table}[ht]
  \centering
  \begin{tabular}[h]{|p{.3\linewidth}|p{.7\linewidth}|}
\hline
bfd/lynx-core.c       &  BFD back end for Lynx core files \\
bfd/mach-o.c          &  Mach-O support for BFD. \\
bfd/Makefile.am       &  Process this file with automake to generate Makefile.in \\
bfd/Makefile.in       &  Makefile.in generated by automake 1.11.1 from Makefile.am. \\
bfd/mipsbsd.c         &  BFD backend for MIPS BSD (a.out) binaries. \\
bfd/netbsd-core.c     &  BFD back end for NetBSD style core files \\
bfd/nlm32-sparc.c     &  Support for 32-bit SPARC NLM (NetWare Loadable Module) \\
bfd/pdp11.c           &  BFD back-end for PDP-11 a.out binaries. \\
bfd/reloc.c           &  BFD support for handling relocation entries. \\
bfd/sparclinux.c      &  BFD back-end for linux flavored sparc a.out binaries. \\
bfd/sparclynx.c       &  BFD support for Sparc binaries under LynxOS. \\
bfd/sparcnetbsd.c     &  BFD back-end for NetBSD/sparc a.out-ish binaries. \\
bfd/sunos.c           &  BFD backend for SunOS binaries. \\
bfd/targets.c         &  Generic target-file-type support for the BFD library. \\
\hline
\end{tabular}
\caption[List of files 2]{Continued from
  Table~\ref{tab:bfd:sparc:files:1}. List of files in
  \texttt{binutils/bfd} that contain the word ``\texttt{sparc}''.}
\label{tab:bfd:sparc:files:2}
\end{table}

We can  eliminate files that are not  related to ELF in  any way.  For
example they may  be dealing with the COFF format.  Or  they may be 64
bit;  AJIT is  a 32  bit system  as of  date.\footnote{2020.}   Of the
remaining, some would  most certainly be candidate files  for the AJIT
port  and some  would probably  be.  Table~\ref{tab:bfd:sparc:files:3}
lists these files  with a tag ``yes'' if the file  is most certainly a
candidate for AJIT port or a tag ``maybe''.
\begin{table}[ht]
  \centering
  \begin{tabular}[h]{|l|l|}
\hline
bfd/archures.c   & yes \\
bfd/config.bfd   & yes \\
bfd/cpu-sparc.c   & yes \\
bfd/elf32-sparc.c   & yes \\
bfd/elf-bfd.h   & yes \\
bfd/elf.c   & yes \\
bfd/elfcode.h   & yes \\
bfd/elfxx-sparc.c   & yes \\
bfd/elfxx-sparc.h   & yes \\
bfd/targets.c   & yes \\
\hline
bfd/bfd-in2.h   & maybe \\
bfd/bfd-in.h   & maybe \\
bfd/bfd.m4   & maybe \\
bfd/configure   & maybe \\
bfd/configure.in   & maybe \\
bfd/elf64-ajit.c   & maybe \\
bfd/elf64-sparc.c   & maybe \\
bfd/freebsd.h   & maybe \\
bfd/libbfd.h   & maybe \\
bfd/Makefile.am   & maybe \\
bfd/Makefile.in   & maybe \\
bfd/nlm32-sparc.c   & maybe \\
bfd/reloc.c   & maybe \\
\hline
\end{tabular}
\caption[List of files 3]{List of files in \texttt{binutils/bfd} that
  contain the word ``\texttt{sparc}'' and are possible candidate files
  for the AJIT port.} 
\label{tab:bfd:sparc:files:3}
\end{table}
\begin{table}[ht]
  \centering
  \begin{tabular}[h]{|p{.3\linewidth}|p{.7\linewidth}|}
\hline
bfd/archures.c (y)       &  BFD library support routines for architectures. \\
    \hline
bfd/bfd-in2.h (m)     & 
\begin{minipage}[h]{\linewidth}
  Main  header file  for the  bfd library:  portable access  to object
  files.  This file is automatically generated from

  \begin{tabular}[h]{|l|l|l|}
    \hline 
    ``bfd-in.h'' &    ``init.c'' &    ``opncls.c'' \\
    ``libbfd.c'' &    ``bfdio.c'' &   ``bfdwin.c'' \\
    ``section.c'' &   ``archures.c'' &``reloc.c''  \\
    ``syms.c'' &      ``bfd.c'' &     ``archive.c'' \\
    ``corefile.c'' &  ``targets.c'' & ``format.c'' \\
    ``linker.c'' &    ``simple.c''  &  ``compress.c''\\
    \hline 
  \end{tabular}

  Run ``\texttt{make headers}'' in your build \texttt{bfd/} to regenerate.
\end{minipage} \\
    \hline
bfd/bfd-in.h (m)         &  Main header file for the bfd library:  portable access   to   object   files. \\
bfd/bfd.m4 (m)           &  This file was derived from acinclude.m4. \\
    \hline
bfd/config.bfd (y)       &  
\begin{minipage}[h]{\linewidth}
  Convert  a canonical  host type  into a  BFD host  type.   Set shell
  variable \texttt{targ} to canonical target
  name, and run using ``\texttt{. config.bfd}''. \\
  Sets the following shell variables: \\
  \begin{tabular}[h]{|l|l|}
    \hline
  \texttt{targ\_defvec} &	Default vector for this target \\
  \texttt{targ\_selvecs} &	Vectors to build for this target \\
  \texttt{targ64\_selvecs} &	\parbox{.65\linewidth}{Vectors     to
    build    if \texttt{--enable-64-bit-bfd}  is  given or if host is
    64 bit.} \\ 
  \texttt{targ\_archs} &	Architectures for this target \\
  \texttt{targ\_cflags} &	\texttt{\$(CFLAGS)} for this target (FIXME: pretty bogus) \\
  \texttt{targ\_underscore} &	Whether underscores are used: yes or no \\
    \hline
\end{tabular}
\end{minipage}\\
    \hline
bfd/configure (m)        &  Guess values for system-dependent variables and create Makefiles. \\
bfd/configure.in (m)     &  Process this file with autoconf to produce a configure script. \\
bfd/cpu-sparc.c (y)      &  BFD support for the SPARC architecture. \\
bfd/elf32-sparc.c (y)    &  SPARC-specific support for 32-bit ELF. \\
bfd/elf64-ajit.c (m)     &  SPARC-specific support for 64-bit ELF \\
bfd/elf64-sparc.c (m)    &  SPARC-specific support for 64-bit ELF \\
bfd/elf-bfd.h (y)        &  BFD back-end data structures for ELF files. \\
bfd/elf.c (y)            &  ELF executable support for BFD. \\
bfd/elfcode.h (y)        &  ELF executable support for BFD. \\
bfd/elfxx-sparc.c (y)    &  SPARC-specific support for ELF. \\
bfd/elfxx-sparc.h (y)    &  SPARC ELF specific backend routines. \\
bfd/freebsd.h (m)        &  BFD back-end definitions used by all FreeBSD targets. \\
  \hline
bfd/libbfd.h (m)         &  
\begin{minipage}[h]{\linewidth}
  Declarations  used by  bfd library  *implementation*.  (This include
  file is not  for users of the library.)   This file is automatically
  generated from
  \begin{tabular}[h]{|l|l|l|}
  \hline
  ``libbfd-in.h'' &    ``init.c'' &     ``libbfd.c'' \\
  ``bfdio.c'' &        ``bfdwin.c'' &   ``cache.c''  \\
  ``reloc.c'' &        ``archures.c'' &  ``elf.c'' \\
  \hline
\end{tabular}
  Run  ``\texttt{make  headers}''  in  your  build  \texttt{bfd/}  to
  regenerate.
\end{minipage} \\
\hline
bfd/Makefile.am (m)      &  Process this file with automake to generate Makefile.in \\
bfd/Makefile.in (m)      &  Makefile.in generated by automake 1.11.1 from Makefile.am. \\
bfd/nlm32-sparc.c (m)    &  Support for 32-bit SPARC NLM (NetWare Loadable Module) \\
bfd/reloc.c (m)          &  BFD support for handling relocation entries. \\
bfd/targets.c (y)     &  Generic target-file-type support for the BFD library. \\
\hline
\end{tabular}
\caption[List of files 4]{List of files in \texttt{binutils/bfd} that
  contain the word ``\texttt{sparc}'' and are possible candidate files
  for the AJIT port.} 
\label{tab:bfd:sparc:files:4}
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}[h]{|l|c|p{.63\linewidth}|l|}
\hline
bfd/elf-bfd.h      &01&  BFD back-end data structures for ELF files.                                               & yes   \\
bfd/elf.c          &02&  ELF executable support for BFD.                                                           & yes   \\
bfd/elfcode.h      &03&  ELF executable support for BFD. External to internal conversions.                         & yes   \\
bfd/elfxx-sparc.c  &04&  SPARC-specific support for ELF.                                                           & yes   \\
bfd/elfxx-sparc.h  &05&  SPARC ELF specific backend routines.                                                      & yes   \\
bfd/libbfd.h       &06&  Declarations used by bfd library; generated file, see source files                        & yes   \\
bfd/targets.c      &07&  Generic target-file-type support for the BFD library.                                     & yes   \\
bfd/reloc.c        &08&  BFD support for handling relocation entries.                                              & yes   \\
bfd/elf32-sparc.c  &09&  SPARC-specific support for 32-bit ELF.                                                    & yes   \\
bfd/cpu-sparc.c    &10&  BFD support for the SPARC architecture.                                                   & yes   \\
bfd/archures.c     &11&  BFD library support routines for architectures.                                           & yes   \\
bfd/config.bfd     &12&  Convert a canonical host type into a BFD host type.                                       & yes   \\
bfd/bfd-in2.h      &13&  Main header file for the bfd library: portable \& generated                               & yes   \\
bfd/bfd-in.h       &14&  Main header file for the bfd library:  portable                                           & yes   \\
bfd/bfd.m4         &21&  This file was derived from acinclude.m4. \textbf{To Check}                                & maybe \\
bfd/configure.in   &22&  Process this file with autoconf to produce a configure script.                            & maybe \\
bfd/Makefile.am    &22&  Process this file with automake to generate Makefile.in                                   & no    \\
bfd/elf64-ajit.c   &22&  SPARC-specific support for 64-bit ELF - to DENY 64 bit support                            & maybe \\
bfd/nlm32-sparc.c  &22&  Support for 32-bit SPARC NLM (NetWare Loadable Module)                                    & no    \\
bfd/freebsd.h      &23&  BFD back-end definitions used by all FreeBSD targets.                                     & no    \\
bfd/configure      &23&  Guess values for system-dependent variables and                                           & no    \\
bfd/Makefile.in    &23&  Makefile.in generated by automake 1.11.1 from Makefile.am.                                & no    \\
bfd/elf64-sparc.c  &23&  SPARC-specific support for 64-bit ELF                                                     & no    \\
\hline
\end{tabular}
\caption[List of files 5]{List of files in \texttt{binutils/bfd} that
  contain the word ``\texttt{sparc}'' and that are possible candidate
  files for the AJIT port along with their number in the sequence of
  modifications.} 
\label{tab:bfd:sparc:files:5}
\end{table}

In  the following  sections we  look at  each file  in  detail.  These
sections are written  by trying to guess the  most probable next file,
and then  going back and forth across  the other files to  fill in the
information.

\subsection{\texttt{bfd/elf-bfd.h}: Yes}
\label{sec:bfd:elf-bfd.h}

We take this  as the first file to examine.  Among  the first files it
includes  is: \texttt{include/elf/common.h}  which has  the  basic ELF
definitions implemented  for the GNU BFD system.   For the definitions
of ELF format,  refer to the standard reference  [ELF REFERENCE HERE].
Among  the  important fields  is  the  \texttt{e\_machine} field.   We
reproduce the relevant comment in \texttt{include/elf/common.h} below:
\begin{verbatim}
Values  for  e_machine,  which  identifies  the  architecture.   These
numbers are officially assigned  by registry@sco.com.  See below for a
list of ad-hoc numbers used during initial development.

If it is  necessary to assign new unofficial  EM_* values, please pick
large random numbers (0x8523, 0xa7f2, etc.) to minimize the chances of
collision with official or non-GNU unofficial values.

NOTE: Do not  just increment the most recent  number by one.  Somebody
else somewhere  will do exactly  the same thing,  and you will  have a
collision.  Instead, pick a random number.

Normally, each entity or maintainer  responsible for a machine with an
unofficial e_machine number should eventually ask registry@sco.com for
an officially blessed number to be added to the list above.
\end{verbatim}
We will  assign a temporary value  0xABCD as of now  (i.e. 2020) until
the AJIT architecture matures  for a more global standardised support.
At that point, we should follow the instructions in the comment above.
We add the following to \texttt{include/elf/common.h}:

\verb|#define  EM_AJIT  0xABCD   /* The IITB AJIT Processor */|

Note that  this change  will reflect only  after the support  is fully
implemented.

The two other  files included are: \texttt{include/elf/internal.h} and
\texttt{include/elf/external.h}.  These  respectively describe the ELF
format within the BFD system when in-memory and in-file.

An enum, ``\texttt{enum elf\_target\_id}''  is used to identify target
specific    extensions    to    the    \texttt{elf\_obj\_tdata}    and
\texttt{elf\_link\_hash\_table}    structures.    Both    the   latter
structures are in this file too.   Since AJIT has no extensions, we do
not seem to need adding an AJIT identifier to this enum.  If, however,
we do need to add then there are two main issues to consider given
that the enum constants are lexicographically ordered:
\begin{enumerate}
\item \label{elf-bfd:h:lexical:order} The name ``AJIT'' will appear as
  the first enum in the  lexicographical order.  That will offset each
  subsequent enum  value by  +1 relative to  its previous  value.  One
  value  from this  enum  gets built  into  the tools  for a  specific
  system; in particular the GNU BFD library on that system.  This is a
  potential problem.   If, for a system  (say the i386),  we build two
  GNU BFD  library versions, one  using the standard binutils  and the
  other using binutils with AJIT  support, then the libraries will use
  different indices internally.  If these indices result in different,
  but legal,  ELF processing  then we have  a problem.   Our resulting
  system is fragile and will break easily.
\item \label{elf-bfd:h:no:lexical:order} The other choice to place the
  ``AJIT'' enum  is at the  second last position.  This  will preserve
  the enums of all the other  supported targets.  We will not have the
  problem in \ref{elf-bfd:h:lexical:order} above.  However, some other
  development effort might  add another target to binutils  and at the
  same  place!  Unless  it so  happens that  the tools  for  these two
  non-standard targets come together  we will not have problems.  This
  is a low probability event, and we ignore it.  If both these targets
  become standard then the development effort will have to ensure that
  these have distinct enum values.
\end{enumerate}


\subsection{\texttt{bfd/archures.c}: Yes}
\label{sec:bfd:archures.c}

From the comments in the file we summarize:

About Architectures

The BFD approach keeps one atom in a BFD describing the architecture
of the data attached to the BFD: a pointer to a
``\texttt{bfd\_arch\_info\_type}''.

Pointers to structures can be requested independently of a BFD
	so that an architecture's information can be interrogated
	without access to an open BFD.

	The architecture information is provided by each architecture package.
	The set of default architectures is selected by the macro
	``\texttt{SELECT\_ARCHITECTURES}''.  This is normally set up in the
	@file{config/@var{target}.mt} file of your choice.  If the name is not
	defined, then all the architectures supported are included.

	When BFD starts up, all the architectures are called with an
	initialize method.  It is up to the architecture back end to
	insert as many items into the list of architectures as it wants to;
	generally this would be one for each machine and one for the
	default case (an item with a machine field of 0).

	BFD's idea of an architecture is implemented in	@file{archures.c}.
*/

/*

SUBSECTION
	bfd\_architecture

DESCRIPTION
	This enum gives the object file's CPU architecture, in a
	global sense---i.e., what processor family does it belong to?
	Another field indicates which processor within
	the family is in use.  The machine gives a number which
	distinguishes different versions of the architecture,
	containing, for example, 2 and 3 for Intel i960 KA and i960 KB,
	and 68020 and 68030 for Motorola 68020 and 68030.



\subsection{\texttt{bfd/config.bfd}: Yes}
\label{sec:bfd:config.bfd}


\subsection{\texttt{bfd/cpu-sparc.c}: Yes}
\label{sec:bfd:cpu-sparc.c}


\subsection{\texttt{bfd/elf32-sparc.c}: Yes}
\label{sec:bfd:elf32-sparc.c}


\subsection{\texttt{bfd/elf.c}: Yes}
\label{sec:bfd:elf.c}

The only  place needed  is the  routine that groks  the core  file for
NETBSD.  Since AJIT is not ported  to any other OS except GNU/Linux we
do not need to add or change any code in this file.

\subsection{\texttt{bfd/elfcode.h}: Yes}
\label{sec:bfd:elfcode.h}

This    file    returns    a    \texttt{bfd\_target}    (defined    in
\texttt{bfd/bfd-in2.h}) object from the ELF file.  Also \texttt{struct
  bfd} is in the same file.

% /* Check to see if the file associated with ABFD matches the target vector
%    that ABFD points to.

%    Note that we may be called several times with the same ABFD, but different
%    target vectors, most of which will not match.  We have to avoid leaving
%    any side effects in ABFD, or any data it points to (like tdata), if the
%    file does not match the target vector.  */

% const bfd_target *
% elf_object_p (bfd *abfd)


\subsection{\texttt{bfd/elfxx-sparc.c}: Yes}
\label{sec:bfd:elfxx-sparc.c}


\subsection{\texttt{bfd/elfxx-sparc.h}: Yes}
\label{sec:bfd:elfxx-sparc.h}


\subsection{\texttt{bfd/targets.c}: Yes}
\label{sec:bfd:targets.c}


\subsection{\texttt{bfd/bfd-in2.h}: Maybe}
\label{sec:bfd:bfd-in2.h}


\subsection{\texttt{bfd/bfd-in.h}: Maybe}
\label{sec:bfd:bfd-in.h}


\subsection{\texttt{bfd/bfd.m4}: Maybe}
\label{sec:bfd:bfd.m4}


\subsection{\texttt{bfd/configure}: Maybe}
\label{sec:bfd:configure}


\subsection{\texttt{bfd/configure.in}: Maybe}
\label{sec:bfd:configure.in}


\subsection{\texttt{bfd/elf64-ajit.c}: Maybe}
\label{sec:bfd:elf64-ajit.c}


\subsection{\texttt{bfd/elf64-sparc.c}: Maybe}
\label{sec:bfd:elf64-sparc.c}


\subsection{\texttt{bfd/freebsd.h}: Maybe}
\label{sec:bfd:freebsd.h}


\subsection{\texttt{bfd/libbfd.h}: Maybe}
\label{sec:bfd:libbfd.h}


\subsection{\texttt{bfd/Makefile.am}: Maybe}
\label{sec:bfd:Makefile.am}


\subsection{\texttt{bfd/Makefile.in}: Maybe}
\label{sec:bfd:Makefile.in}


\subsection{\texttt{bfd/nlm32-sparc.c}: Maybe}
\label{sec:bfd:nlm32-sparc.c}


\subsection{\texttt{bfd/reloc.c}: Maybe}
\label{sec:bfd:reloc.c}

\section{Studying the Build Process}
\label{sec:build:study}

To study the build process we build the GNU binutils-2.22 for at least
two targets: a native  and a cross.  Our host machine is  a 64 bit x86
as we write this.  So we use  the x86 or i386 as a the native machine,
and the  SPARC as the  cross machine.\footnote{For a cross  target our
  build generates binaries that run \textbf{on} the host machine (i386
  in this  case) and generate  output \textbf{for} the  target machine
  (SPARC  in this  case).}   We install  the  binaries built  on to  a
separate  directory  hierarchy  for   each  target  than  the  default
\texttt{/usr/local}.  We will refer to  the i386 install folder as the
\texttt{\$X86INSTALLDIR}   and  the  SPARC   install  folder   as  the
\texttt{\$SPARCINSTALLDIR}.

The  build   follows  the  usual  steps  to   building  GNU  software:
\texttt{configure} followed by  \texttt{make} followed by \texttt{make
  install}.  The standard  output and the standard error  of each step
is  individually  redirected into  files.   This  allows a  systematic
exploration  of  the sequence  of  the  build  process that  has  been
actually followed.  Here are the commands used to capture the details
of the i386 build:
\begin{enumerate}[noitemsep]
\item  \texttt{cd  BINUTILS-SOURCES-FOR-i386}:  change to  the  folder
  where  we have the  pristine binutils  sources to  be built  for the
  i386.
\item           \texttt{./configure           --prefix=\$X86INSTALLDIR
    --target=i386-pc-linux-gnu > i386-configure.stdout 2>
    i386-configure.stderr} \\
  This command sets  up the build for the i386  target.  The target is
  specified using the  \texttt{--target} option to \texttt{configure}.
  The  specification  follows  the  GNU  rules;  the  i386  target  is
  specified as: \texttt{i386-pc-linux-gnu}.  The build process is also
  informed    that    the   installation    is    to    be   in    the
  \texttt{\$X86INSTALLDIR}  folder.  Apart from  checking if  the host
  has all  the support required for the  build, the \texttt{configure}
  may also set up some variables sensitive to the target, and may even
  generate  some files that  are target  specific.  In  particular the
  \texttt{Makefile}  that  will   build  the  entire  target  specific
  binutils is generated towards the end of its run.
\item \texttt{make > i386-make.stdout 2> i386-make.stderr} \\
  Using the \texttt{Makefile} generated  by configure, this command is
  the  main workhorse  that builds  the software  system.   Usually it
  compiles and links the programs.   At times it also generates target
  specific files.  Both these are critical to our study below.
\item \texttt{make install > i386-install.stdout 2>
    i386-install.stderr} \\
  This command  installs the binaries, libraries and  any header files
  generated by the build in the required directory hierarchy below the
  \texttt{\$X86INSTALLDIR} folder.
\end{enumerate}
Similarly for the SPARC build we have in summary:
\begin{enumerate}[noitemsep]
\item  \texttt{cd BINUTILS-SOURCES-FOR-SPARC}:  change  to the  folder
  where  we have the  pristine binutils  sources to  be built  for the
  SPARC.
\item \texttt{./configure --prefix=\$SPARCINSTALLDIR
    --target=sparc-linux-gnu > sparc-configure.stdout 2> sparc-configure.stderr} 
\item \texttt{make > sparc-make.stdout 2> sparc-make.stderr} 
\item \texttt{make install > sparc-install.stdout 2> sparc-install.stderr} 
\end{enumerate}

The \texttt{configure} sequence of configuring over the folders in binutils is:
\begin{enumerate}[noitemsep]
\item Configuring in ./intl
\item Configuring in ./libiberty
\item Configuring in ./bfd
\item Configuring in ./opcodes
\item Configuring in ./binutils
\item Configuring in ./etc
\item Configuring in ./gas
\item Configuring in ./gprof
\item Configuring in ./ld
\end{enumerate}

Assuming  a successful build  our main  source of  study of  the build
process are the \texttt{*.stdout}  files.  Study of these files yields
the following sequence:
\begin{enumerate}[noitemsep]
\item Configuring in ./intl
\item Configuring in ./libiberty
\item Configuring in ./bfd
\item The files created during \texttt{configure} in \texttt{bfd/} are:
  \begin{enumerate}
  \item config.status: creating Makefile
  \item config.status: creating doc/Makefile
  \item config.status: creating bfd-in3.h:
  \item config.status: creating po/Makefile.in
  \item config.status: creating config.h
  \end{enumerate}
\item Building the libiberty library.  The build process configures in
  \texttt{bfd} \emph{before} it enters the \texttt{libiberty} to build
  this   library.    C   files    that   contribute   to   this   are:

  regex.c,   cplus-dem.c,  cp-demangle.c,  md5.c,   sha1.c,  alloca.c,
  argv.c, choose-temp.c, concat.c, cp-demint.c, crc32.c, dyn-string.c,
  fdmatch.c,  fibheap.c, filename$\_$cmp.c,  floatformat.c, fnmatch.c,
  fopen$\_$unlocked.c,  getopt.c,  getopt1.c, getpwd.c,  getruntime.c,
  hashtab.c, hex.c,  lbasename.c, lrealpath.c, make-relative-prefix.c,
  make-temp-file.c,  objalloc.c,  obstack.c, partition.c,  pexecute.c,
  physmem.c,  pex-common.c,   ne.c,  ne.c,  pex-unix.c,  safe-ctype.c,
  bject.c,    bject.c,   bject-coff.c,    bject-coff.c,   bject-elf.c,
  bject-elf.c, bject-mach, bject-mach, sort.c, spaces.c, splay-tree.c,
  stack-limit.c,   strerror.c,   strsignal.c,  rdinary.c,   rdinary.c,
  xatexit.c,  xexit.c, xmalloc.c,  xmemdup.c,  xstrdup.c, xstrerror.c,
  xstrndup.c, setproctitle.c

  % \texttt{regex.c},    \texttt{cplus-dem.c},   \texttt{cp-demangle.c},
  % \texttt{md5.c}, \texttt{sha1.c}, \texttt{alloca.c}, \texttt{argv.c},
  % \texttt{choose-temp.c},   \texttt{concat.c},   \texttt{cp-demint.c},
  % \texttt{crc32.c},     \texttt{dyn-string.c},     \texttt{fdmatch.c},
  % \texttt{fibheap.c},                         \texttt{filename\_cmp.c},
  % \texttt{floatformat.c},                           \texttt{fnmatch.c},
  % \texttt{fopen\_unlocked.c},  \texttt{getopt.c},  \texttt{getopt1.c},
  % \texttt{getpwd.c},     \texttt{getruntime.c},    \texttt{hashtab.c},
  % \texttt{hex.c},      \texttt{lbasename.c},     \texttt{lrealpath.c},
  % \texttt{make-relative-prefix.c},           \texttt{make-temp-file.c},
  % \texttt{objalloc.c},    \texttt{obstack.c},    \texttt{partition.c},
  % \texttt{pexecute.c},    \texttt{physmem.c},   \texttt{pex-common.c},
  % \texttt{ne.c},          \texttt{ne.c},          \texttt{pex-unix.c},
  % \texttt{safe-ctype.c},      \texttt{bject.c},      \texttt{bject.c},
  % \texttt{bject-coff.c},  \texttt{bject-coff.c}, \texttt{bject-elf.c},
  % \texttt{bject-elf.c},    \texttt{bject-mach},   \texttt{bject-mach},
  % \texttt{sort.c},      \texttt{spaces.c},      \texttt{splay-tree.c},
  % \texttt{stack-limit.c},  \texttt{strerror.c},  \texttt{strsignal.c},
  % \texttt{rdinary.c},      \texttt{rdinary.c},     \texttt{xatexit.c},
  % \texttt{xexit.c},       \texttt{xmalloc.c},      \texttt{xmemdup.c},
  % \texttt{xstrdup.c}, \texttt{xstrerror.c}, \texttt{xstrndup.c}.

% regex.c  cplus-dem.c  cp-demangle.c  md5.c  sha1.c  alloca.c  argv.c
% choose-temp.c  concat.c  cp-demint.c  crc32.c  dyn-string.c
% fdmatch.c  fibheap.c  filename_cmp.c  floatformat.c  fnmatch.c
% fopen_unlocked.c  getopt.c  getopt1.c  getpwd.c  getruntime.c
% hashtab.c  hex.c  lbasename.c  lrealpath.c  make-relative-prefix.c
% make-temp-file.c  objalloc.c  obstack.c  partition.c  pexecute.c
% physmem.c  pex-common.c ne.c  ne.c   pex-unix.c  safe-ctype.c
% bject.c  bject.c  bject-coff.c  bject-coff.c  bject-elf.c
% bject-elf.c  bject-mach bject-mach  sort.c  spaces.c  splay-tree.c
% stack-limit.c  strerror.c  strsignal.c rdinary.c  rdinary.c
% xatexit.c  xexit.c  xmalloc.c  xmemdup.c  xstrdup.c  xstrerror.c
% xstrndup.c  setproctitle.c

  After removing  any previous libiberty library  files, the libiberty
  library is built afresh using \texttt{ar} and \texttt{ranlib}.  Also
  a   list  of   these  object   files  is   collected  in   the  file
  \texttt{required-list}.
\item Building in \texttt{bfd}.

  The sequence here is:
  \begin{enumerate}[noitemsep]
  \item Create \texttt{bfdver.h}
  \item Create \texttt{elf32-target.h}: Commands sequence is: 
    \texttt{rm -f elf32-target.h}, 
    \texttt{sed -e s/NN/32/g < ./elfxx-target.h > elf32-target.new}, 
    \texttt{mv -f elf32-target.new elf32-target.h}.
  \item Create \texttt{elf64-target.h}: Commands sequence is: 
    \texttt{rm -f elf64-target.h}, 
    \texttt{sed -e s/NN/64/g < ./elfxx-target.h > elf64-target.new}, 
    \texttt{mv -f elf64-target.new elf64-target.h}.
  \item Create \texttt{targmatch.h}: Commands sequence is: 
    \texttt{rm -f targmatch.h}, 
    \texttt{sed -f ./targmatch.sed < ./config.bfd > targmatch.new}, 
    \texttt{mv -f targmatch.new targmatch.h}.
  \item Build the BFD specific documentation.  We skip these details.
  \item Create \texttt{bfd.h}.  Commands sequence is: 
    \texttt{rm -f bfd-tmp.h}, 
    \texttt{cp bfd-in3.h bfd-tmp.h}, 
    \texttt{/bin/bash ./../move-if-change bfd-tmp.h bfd.h}, 
    \texttt{rm -f bfd-tmp.h}, 
    \texttt{touch stmp-bfd-h}, 
  \end{enumerate}
\end{enumerate}




